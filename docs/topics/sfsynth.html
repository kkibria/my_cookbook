<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Understanding Soundfont Synthesis - My Development Cookbook</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">My Development Cookbook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="understanding-soundfont-synthesis"><a class="header" href="#understanding-soundfont-synthesis">Understanding Soundfont Synthesis</a></h1>
<p>I took RustySynth as an example from github <a href="https://github.com/sinshu/rustysynth">https://github.com/sinshu/rustysynth</a>, which is written in <code>rust</code>.</p>
<p>Below is an overview of how the various pieces of RustySynth fit together—both
in terms of “who depends on whom” (module/dependency structure) and in terms of
the main runtime call‐hierarchy (what calls what at runtime).</p>
<hr />
<h2 id="1-high-level-cargoworkspace-layout"><a class="header" href="#1-high-level-cargoworkspace-layout">1. High-Level Cargo/Workspace Layout</a></h2>
<p>At the top level, the repository has three main sub-directories (workspace members):</p>
<ul>
<li>
<p><strong><code>rustysynth/</code></strong>
The core synthesizer library (this is where all of the SoundFont parsing, voice management, sample generation, and effects live).</p>
</li>
<li>
<p><strong><code>rustysynth_test/</code></strong>
A small crate for running unit/integration tests against the core library.</p>
</li>
<li>
<p><strong><code>example/</code></strong>
One or more example programs (showing how to load a SoundFont, create a <code>Synthesizer</code>, play a MIDI file, etc.).</p>
</li>
</ul>
<p>For our purposes, everything we care about is in <code>rustysynth/src/</code>. Below is a
rough sketch of the files you’ll find there (names taken from docs.rs and a
GitHub directory listing) :</p>
<pre><code>rustysynth/
├─ Cargo.toml
└─ src/
   ├─ error.rs
   ├─ midi_file.rs
   ├─ midi_file_sequencer.rs
   ├─ sound_font.rs
   ├─ synthesizer_settings.rs
   ├─ synthesizer.rs
   ├─ voice.rs
   ├─ oscillator.rs
   ├─ envelope.rs
   ├─ comb_filter.rs
   ├─ all_pass_filter.rs
   ├─ reverb.rs
   ├─ chorus.rs
   └─ … (possibly a few small helpers, but these are the main pieces)
</code></pre>
<p>Each of the <code>.rs</code> files corresponds to a <code>mod</code> in <code>lib.rs</code>, and together they
form the library’s public/exported API (plus internal helpers).</p>
<hr />
<h2 id="2-moduledependency-structure"><a class="header" href="#2-moduledependency-structure">2. Module/Dependency Structure</a></h2>
<p>Below is a simplified “dependency graph” of modules—i.e. which <code>mod</code> files refer
to which other modules. Arrows (→) mean “depends on / uses functionality from.”</p>
<pre><code> ┌─────────────────┐
 │   error.rs      │   ←── defines `MidiFileError`, `SoundFontError`, `SynthesizerError` 
 └─────────────────┘
          ▲
          │
 ┌─────────────────┐
 │   sound_font.rs │  ←── uses `error::SoundFontError`, plus low‐level I/O traits (`Read`, `Seek`)
 └─────────────────┘
          ▲
          │
 ┌────────────────────────────┐
 │   midi_file.rs             │  ←── uses `error::MidiFileError`
 └────────────────────────────┘
          ▲
          │
 ┌──────────────────────────────────────┐
 │   midi_file_sequencer.rs             │  ←── uses `MidiFile` (from midi_file.rs)  
 │                                      |      and `Synthesizer` (from synthesizer.rs)  
 └──────────────────────────────────────┘
          ▲
          │
 ┌──────────────────────────────┐
 │  synthesizer_settings.rs     │  ←── trivial: only holds numeric fields (sample_rate, block_size, max_polyphony)  
 └──────────────────────────────┘
          ▲
          │
 ┌──────────────────────────────┐
 │   synthesizer.rs             │  ←── uses:  
 │                              │        • `SynthesizerSettings`  
 │                              │        • `SoundFont`  
 │                              │        • `Voice` (from voice.rs)  
 │                              │        • DSP buffers (Vec&lt;f32&gt;)  
 │                              │        • Effects (`Reverb`, `Chorus`)  
 └──────────────────────────────┘
          ▲
          │
 ┌──────────────────────────────┐
 │   voice.rs                   │  ←── uses:  
 │                              │        • `Oscillator` (from oscillator.rs)  
 │                              │        • `Envelope` (from envelope.rs)  
 │                              │        • `CombFilter`, `AllPassFilter` (from their own modules)  
 └──────────────────────────────┘
          ▲
          │
 ┌──────────────────────────────┐
 │   oscillator.rs              │  (no dependencies except `std::f32::consts::PI`)  
 └──────────────────────────────┘

 ┌──────────────────────────────┐
 │   envelope.rs                │  (no dependencies beyond basic math)  
 └──────────────────────────────┘

 ┌──────────────────────────────┐
 │   comb_filter.rs             │  (no external dependencies—just a buffer and feedback logic)  
 └──────────────────────────────┘

 ┌──────────────────────────────┐
 │   all_pass_filter.rs         │  (stateless/all-pass filter logic only)  
 └──────────────────────────────┘

 ┌──────────────────────────────┐
 │   reverb.rs                  │  ←── uses `CombFilter` and `AllPassFilter`  
 └──────────────────────────────┘

 ┌──────────────────────────────┐
 │   chorus.rs                  │  (similar: uses one or more LFOs + delay lines; no other cross‐deps)  
 └──────────────────────────────┘
</code></pre>
<ul>
<li>
<p><strong><code>error.rs</code></strong> defines the crate’s error types (<code>MidiFileError</code>, <code>SoundFontError</code>, <code>SynthesizerError</code>). Other modules simply import these via <code>pub use error::…;</code>.</p>
</li>
<li>
<p><strong><code>sound_font.rs</code></strong> is responsible for parsing an SF2 file (<code>SoundFont::new(...)</code>) and exposing types like <code>Preset</code>, <code>SampleHeader</code>, etc. It only depends on I/O traits (<code>Read</code>, <code>Seek</code>) and <code>error::SoundFontError</code>.</p>
</li>
<li>
<p><strong><code>midi_file.rs</code></strong> parses a standard MIDI file and exposes <code>MidiFile</code> and its associated data structures (tracks, events). It depends on <code>error::MidiFileError</code>.</p>
</li>
<li>
<p><strong><code>midi_file_sequencer.rs</code></strong> drives playback of a <code>MidiFile</code> through a <code>Synthesizer</code>. Internally, it calls methods on <code>Synthesizer</code> (e.g. <code>note_on</code>, <code>note_off</code>, <code>render</code>).</p>
</li>
<li>
<p><strong><code>synthesizer_settings.rs</code></strong> is trivial—just a small struct holding <code>sample_rate</code>, <code>block_size</code>, <code>maximum_polyphony</code>.</p>
</li>
<li>
<p><strong><code>synthesizer.rs</code></strong> is the heart of the real-time (or block‐based) engine. It:</p>
<ol>
<li>
<p>Holds an <code>Arc&lt;SoundFont&gt;</code> (so multiple threads can share the same SoundFont safely).</p>
</li>
<li>
<p>Keeps a <code>Vec&lt;Voice&gt;</code> (one slot per possible voice).</p>
</li>
<li>
<p>Keeps per-channel state (<code>channels: Vec&lt;ChannelState&gt;</code>).</p>
</li>
<li>
<p>Manages effect units (<code>Reverb</code>, <code>Chorus</code>).</p>
</li>
<li>
<p>Exposes methods like</p>
<ul>
<li><code>fn new(sound_font: &amp;Arc&lt;SoundFont&gt;, settings: &amp;SynthesizerSettings) -&gt; Result&lt;Self, SynthesizerError&gt;</code></li>
<li><code>fn note_on(&amp;mut self, channel: u8, key: u8, velocity: u8)</code></li>
<li><code>fn note_off(&amp;mut self, channel: u8, key: u8, velocity: u8)</code></li>
<li><code>fn render(&amp;mut self, left: &amp;mut [f32], right: &amp;mut [f32])</code></li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong><code>voice.rs</code></strong> represents a single active note (“voice”). Each voice holds:</p>
<ol>
<li>An <code>Oscillator</code> (for waveform generation).</li>
<li>An <code>Envelope</code> (for ADSR or similar amplitude shaping).</li>
<li>A small bank of <code>CombFilter</code>s and <code>AllPassFilter</code>s (for per-voice filtering).</li>
<li>A reference to the <code>SampleHeader</code> (so it knows which PCM data to read).</li>
<li>Methods like <code>fn new(…)</code> to create a voice from a given <code>InstrumentRegion</code> or <code>PresetRegion</code>, and <code>fn process_block(&amp;mut self, left: &amp;mut [f32], right: &amp;mut [f32])</code> to generate its output into the provided audio block.</li>
</ol>
</li>
<li>
<p><strong><code>oscillator.rs</code></strong> implements low-level math for, e.g., generating a sine wave, a square wave, or reading a PCM sample from memory. It does not depend on any other module except <code>std::f32::consts</code>.</p>
</li>
<li>
<p><strong><code>envelope.rs</code></strong> implements standard envelope generators (ADSR). No cross-deps.</p>
</li>
<li>
<p><strong><code>comb_filter.rs</code></strong> and <strong><code>all_pass_filter.rs</code></strong> implement the two basic filter types used both in each voice (for “filter per voice”) and inside the main reverb unit (for “global reverb”).</p>
</li>
<li>
<p><strong><code>reverb.rs</code></strong> builds on <code>CombFilter</code> + <code>AllPassFilter</code> to implement a stereo reverb effect.</p>
</li>
<li>
<p><strong><code>chorus.rs</code></strong> implements a stereo chorus effect (no further dependencies).</p>
</li>
<li>
<p>Finally, <strong><code>lib.rs</code></strong> has lines like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod error;
mod sound_font;
mod midi_file;
mod midi_file_sequencer;
mod synthesizer_settings;
mod synthesizer;
mod voice;
mod oscillator;
mod envelope;
mod comb_filter;
mod all_pass_filter;
mod reverb;
mod chorus;

pub use error::{MidiFileError, SoundFontError, SynthesizerError};
pub use sound_font::SoundFont;
pub use midi_file::{MidiFile, MidiEvent};
pub use midi_file_sequencer::MidiFileSequencer;
pub use synthesizer_settings::SynthesizerSettings;
pub use synthesizer::Synthesizer;
<span class="boring">}</span></code></pre></pre>
<p>so that downstream users can write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rustysynth::SoundFont;
use rustysynth::Synthesizer;
use rustysynth::MidiFile;
use rustysynth::MidiFileSequencer;
<span class="boring">}</span></code></pre></pre>
<p>without needing to know the internal module structure.</p>
</li>
</ul>
<hr />
<h2 id="3-runtime-call-hierarchy-what-happens-when-you-synthesize"><a class="header" href="#3-runtime-call-hierarchy-what-happens-when-you-synthesize">3. Runtime Call-Hierarchy (What Happens When You Synthesize)</a></h2>
<p>Below is the typical sequence of calls, from loading a SoundFont to generating
audio. You can think of this as a “dynamic call graph” that shows how, at
runtime, each component invokes the next.</p>
<pre><code>(1) User code: 
      let mut sf2_file = File::open("SomeSoundFont.sf2")?;
      let sound_font = Arc::new(SoundFont::new(&amp;mut sf2_file)?);
      let settings = SynthesizerSettings::new(44100);
      let mut synth = Synthesizer::new(&amp;sound_font, &amp;settings)?;

  └──▶ SoundFont::new(...) parses the SF2 file, building:
         • a list of Presets
         • for each Preset, a Vec&lt;PresetRegion&gt;
         • each PresetRegion refers to one or more InstrumentRegion
         • each InstrumentRegion points to SampleHeader and bank parameters
         • (Internally, sound_font.rs may also build a “preset_lookup” table, etc.)

(2) User code (optional): 
      // If you want to play a standalone MIDI file:
      let mut midi_file = File::open("SomeSong.mid")?;
      let midi = Arc::new(MidiFile::new(&amp;mut midi_file)?);
      let mut sequencer = MidiFileSequencer::new(synth);

  └──▶ MidiFile::new(...) parses all tracks, tempo maps, events (note on/off, CC, etc.)

  └──▶ MidiFileSequencer::new(...) stores the `Synthesizer` inside itself (by move or by value).

(3) User code: 
      // In a real‐time context, you might spawn an audio thread that repeatedly does:
      //    loop {
      //      sequencer.render(&amp;mut left_buf, &amp;mut right_buf);
      //      send to audio output device
      //    }
      // In an offline context:
      sequencer.play(&amp;midi, /* loop = false */);
      let total_samples = (settings.sample_rate as f64 * midi.get_length()) as usize;
      let mut left  = vec![0.0_f32; total_samples];
      let mut right = vec![0.0_f32; total_samples];
      sequencer.render(&amp;mut left[..], &amp;mut right[..]);

  └──▶ MidiFileSequencer::play(...)  // sets an internal “start_time = 0” or similar

  └──▶ MidiFileSequencer::render(left, right):
        ├── updates internal “current_timestamp” based on block size or realtime clock  
        ├── calls `Synthesizer::note_on/off(...)` for any MIDI events whose timestamps fall in this block  
        └── calls `Synthesizer::render(left, right)`

(4) Synthesizer::note_on(channel, key, velocity):
        ├── Look up which **PresetRegion** should respond (based on channel’s current bank/program).  
        ├── For that PresetRegion, find the matching **InstrumentRegion**(s) for that key &amp; velocity.  
        ├── For each matching InstrumentRegion:
        │     ├── Find a free voice slot (`self.voices[i]` where `i &lt; maximum_polyphony` and voice isn’t already in use).  
        │     ├── Call `Voice::new( instrument_region, sample_rate )` to create a brand-new `Voice` struct.  
        │     ├── Initialize that voice’s fields (oscillator frequencies, envelope ADSR parameters, filter coefficients, etc.).  
        │     └── Store the new `Voice` (or a handle to it) in `self.voices[i]`.  
        └── Return, now that voice is “active.”

(5) Synthesizer::note_off(channel, key, velocity):
        ├── Search through `self.voices` for any voice whose channel/key match this note.  
        ├── For each such voice, call `voice.note_off()` (which typically sets the envelope into its “release” stage).  
        └── Return (voice remains “active” until its envelope fully dies out, at which point Synthesizer may garbage-collect it next block).

(6) Synthesizer::render(left: &amp;mut [f32], right: &amp;mut [f32]):
        ├── Zero out `left[]` and `right[]` for this block.  
        ├── For each active `voice` in `self.voices`:
        │     └── Call `voice.process_block(&amp;mut voice_buf_l, &amp;mut voice_buf_r)`.  
        │           • Inside `Voice::process_block(...)`:  
        │             ├── For each sample index `n` in the block:  
        │             │     ├── `osc_sample = self.oscillator.next_sample()`  
        │             │     ├── `amp_envelope = self.envelope.next_amplitude()`  
        │             │     └── `mixed = osc_sample * amp_envelope`  
        │             │           (optionally: apply per-voice LFO mod, filters, etc.)  
        │             │  
        │             ├── Once the raw waveform is generated, run it through per-voice filters:  
        │             │     • e.g. `comb_out = comb_filter.process(mixed)`  
        │             │     • e.g. `all_pass_out = all_pass_filter.process(comb_out)`  
        │             │     • …repeat for each filter in `self.comb_filters` and `self.all_pass_filters`.  
        │             └── Write the final result into `voice_buf_l[n]` and/or `voice_buf_r[n]`.  
        ├── Accumulate each voice’s output into the master block:  
        │     • `left[n]  += voice_buf_l[n]`  
        │     • `right[n] += voice_buf_r[n]`  
        ├── Once all voices have contributed, apply **global effects** in this order (by default):  
        │     1. `self.reverb.process(&amp;mut left, &amp;mut right)`  
        │     2. `self.chorus.process(&amp;mut left, &amp;mut right)`  
        ├── Multiply each sample in `left[]` and `right[]` by `self.master_volume`.  
        └── Return from `render(…)`—the caller (sequencer or user code) now has a filled audio buffer.

</code></pre>
<h2 id="4-summary-of-who-calls-whom"><a class="header" href="#4-summary-of-who-calls-whom">4. Summary of “Who Calls Whom”</a></h2>
<p>Below is a compact list of “call edges” at runtime, annotated with which module implements which function:</p>
<ol>
<li>
<p><strong>User → <code>SoundFont::new(&amp;mut R: Read + Seek) : Result&lt;SoundFont, SoundFontError&gt;</code></strong><br />
(in <code>sound_font.rs</code>)</p>
</li>
<li>
<p><strong>User → <code>MidiFile::new(&amp;mut R: Read + Seek) : Result&lt;MidiFile, MidiFileError&gt;</code></strong><br />
(in <code>midi_file.rs</code>)</p>
</li>
<li>
<p><strong>User → <code>Synthesizer::new(&amp;Arc&lt;SoundFont&gt;, &amp;SynthesizerSettings) : Result&lt;Synthesizer, SynthesizerError&gt;</code></strong><br />
(in <code>synthesizer.rs</code>)<br />
• inside this constructor, it calls:<br />
  – <code>preset_lookup = SoundFont::build_preset_lookup()</code> (in <code>sound_font.rs</code>)<br />
  – allocates <code>Vec&lt;Voice&gt;</code> slots (initially all “inactive”)<br />
  – constructs <code>Vec&lt;ChannelState&gt;</code> for 16 MIDI channels<br />
  – creates <code>Reverb::new(sample_rate)</code> (in <code>reverb.rs</code>) and <code>Chorus::new(sample_rate)</code> (in <code>chorus.rs</code>)<br />
  – stores <code>block_left = Vec::with_capacity(block_size)</code>, <code>block_right = Vec::with_capacity(block_size)</code>, etc.</p>
</li>
<li>
<p><strong>User → <code>MidiFileSequencer::new(synth: Synthesizer) : MidiFileSequencer</code></strong><br />
(in <code>midi_file_sequencer.rs</code>)<br />
• stores <code>synth</code> internally, sets internal “cursor = 0,” no audio generated yet.</p>
</li>
<li>
<p><strong>User → <code>MidiFileSequencer::play(&amp;MidiFile, loop_flag: bool)</code></strong><br />
(in <code>midi_file_sequencer.rs</code>)<br />
• resets time to zero, sets up internal event iterator from the <code>MidiFile</code>.</p>
</li>
<li>
<p><strong>Caller (sequencer or user) → <code>MidiFileSequencer::render(left, right)</code></strong><br />
(in <code>midi_file_sequencer.rs</code>)<br />
• computes which MIDI events fall into this block’s timestamp range, and for each event:<br />
  – If <code>NoteOn</code>, calls <code>synth.note_on(channel, key, velocity)</code>.<br />
  – If <code>NoteOff</code>, calls <code>synth.note_off(channel, key, velocity)</code>.<br />
• after processing all events, calls <code>synth.render(left, right)</code>.</p>
</li>
<li>
<p><strong>Sequencer → <code>Synthesizer::note_on(channel, key, velocity)</code></strong><br />
(in <code>synthesizer.rs</code>)<br />
• looks up the appropriate <code>PresetRegion</code> via a hash map built at construction.<br />
• calls <code>Voice::new( preset_region, sample_rate )</code><br />
• stores that <code>Voice</code> in the first free slot of <code>self.voices</code>.</p>
</li>
<li>
<p><strong>Sequencer → <code>Synthesizer::note_off(channel, key, velocity)</code></strong><br />
(in <code>synthesizer.rs</code>)<br />
• finds matching voice(s), calls <code>voice.note_off()</code>. (Voice will enter its release phase.)</p>
</li>
<li>
<p><strong>Sequencer or user → <code>Synthesizer::render(left, right)</code></strong><br />
(in <code>synthesizer.rs</code>)<br />
• zeroes out both <code>left</code> and <code>right</code> buffers.<br />
• loops over every active <code>Voice</code> in <code>self.voices</code> and calls <code>voice.process_block(voice_buf_l, voice_buf_r)</code>.<br />
• inside each <code>voice.process_block(...)</code> (in <code>voice.rs</code>):<br />
  – calls <code>Oscillator::next_sample()</code> repeatedly (in <code>oscillator.rs</code>).<br />
  – calls <code>Envelope::next_amplitude()</code> for amplitude shaping (in <code>envelope.rs</code>).<br />
  – sends the raw sample through each <code>CombFilter::process(sample)</code> (in <code>comb_filter.rs</code>).<br />
  – then through each <code>AllPassFilter::process(sample)</code> (in <code>all_pass_filter.rs</code>).<br />
  – writes the final per-voice sample into <code>voice_buf_l[n]</code> and <code>voice_buf_r[n]</code>.<br />
• the synth accumulates each <code>voice_buf_l</code>/<code>voice_buf_r</code> into the master <code>left</code>/<code>right</code> block.<br />
• after all voices are done, calls:<br />
  – <code>Reverb::process(left, right)</code> (in <code>reverb.rs</code>), which internally runs a bank of <code>CombFilter</code>s and <code>AllPassFilter</code>s to produce a stereo reverb tail.<br />
  – <code>Chorus::process(left, right)</code> (in <code>chorus.rs</code>), which applies a short, modulated delay to thicken the sound.<br />
  – scales <code>left[]</code> and <code>right[]</code> by <code>self.master_volume</code>.<br />
• returns.</p>
</li>
</ol>
<hr />
<h2 id="5-who-depends-on-whom-recap"><a class="header" href="#5-who-depends-on-whom-recap">5. “Who Depends on Whom” Recap</a></h2>
<p>Below is a summary list of the modules (in descending dependency order), reiterating what we already sketched above:</p>
<ol>
<li>
<p><strong><code>error.rs</code></strong></p>
<ul>
<li>Defines <code>MidiFileError</code>, <code>SoundFontError</code>, <code>SynthesizerError</code>.</li>
<li>No dependencies on other crate modules (beyond core/std).</li>
</ul>
</li>
<li>
<p><strong><code>sound_font.rs</code></strong></p>
<ul>
<li>Depends on <code>error::SoundFontError</code> and <code>std::io::{Read, Seek}</code>.</li>
<li>Exposes types like <code>SoundFont</code>, <code>Preset</code>, <code>InstrumentRegion</code>, <code>SampleHeader</code>.</li>
</ul>
</li>
<li>
<p><strong><code>midi_file.rs</code></strong></p>
<ul>
<li>Depends on <code>error::MidiFileError</code> and core I/O traits.</li>
<li>Exposes <code>MidiFile</code>, <code>MidiEvent</code>, etc.</li>
</ul>
</li>
<li>
<p><strong><code>midi_file_sequencer.rs</code></strong></p>
<ul>
<li>Depends on <code>midi_file::MidiFile</code> + <code>MidiEvent</code>.</li>
<li>Depends on <code>synthesizer::Synthesizer</code> (calls its <code>note_on</code>, <code>note_off</code>, <code>render</code>).</li>
</ul>
</li>
<li>
<p><strong><code>synthesizer_settings.rs</code></strong></p>
<ul>
<li>No cross‐deps (just holds basic numeric fields).</li>
</ul>
</li>
<li>
<p><strong><code>synthesizer.rs</code></strong></p>
<ul>
<li>Depends on:
<ul>
<li><code>sound_font::SoundFont</code></li>
<li><code>synthesizer_settings::SynthesizerSettings</code></li>
<li><code>voice::Voice</code></li>
<li><code>reverb::Reverb</code></li>
<li><code>chorus::Chorus</code></li>
<li>Basic containers (<code>Vec</code>, <code>Arc</code>, etc.)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>voice.rs</code></strong></p>
<ul>
<li>Depends on:
<ul>
<li><code>oscillator::Oscillator</code></li>
<li><code>envelope::Envelope</code></li>
<li><code>comb_filter::CombFilter</code></li>
<li><code>all_pass_filter::AllPassFilter</code></li>
</ul>
</li>
<li>Also references some of the data structures from <code>sound_font</code> (e.g. the <code>SampleHeader</code> inside an <code>InstrumentRegion</code>).</li>
</ul>
</li>
<li>
<p><strong><code>oscillator.rs</code></strong>, <strong><code>envelope.rs</code></strong>, <strong><code>comb_filter.rs</code></strong>, <strong><code>all_pass_filter.rs</code></strong></p>
<ul>
<li>These are leaf modules. They do not depend on any other RustySynth module. They implement low-level DSP building blocks (waveform generation, ADSR envelopes, comb/all-pass filters).</li>
</ul>
</li>
<li>
<p><strong><code>reverb.rs</code></strong></p>
<ul>
<li>Depends on <code>comb_filter::CombFilter</code> and <code>all_pass_filter::AllPassFilter</code>.</li>
<li>Implements a stereo reverb by chaining eight comb filters + four all-pass filters per channel.</li>
</ul>
</li>
<li>
<p><strong><code>chorus.rs</code></strong></p>
<ul>
<li>Typically implements a simple stereo chorus (delay lines + LFO).</li>
<li>No further cross-deps (just basic numeric math).</li>
</ul>
</li>
</ol>
<hr />
<h2 id="6-putting-it-all-together"><a class="header" href="#6-putting-it-all-together">6. Putting It All Together</a></h2>
<ol>
<li>
<p><strong>Build-time/compile-time structure</strong></p>
<ul>
<li>At compile time, Cargo’s feature resolver v2 (see <code>resolver = "2"</code> in <code>Cargo.toml</code>) wires up all these modules into one library.</li>
<li>The <code>lib.rs</code> (in <code>rustysynth/src/lib.rs</code>) has lines like:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod error;
mod sound_font;
mod midi_file;
mod midi_file_sequencer;
mod synthesizer_settings;
mod synthesizer;
mod voice;
mod oscillator;
mod envelope;
mod comb_filter;
mod all_pass_filter;
mod reverb;
mod chorus;

pub use error::{MidiFileError, SoundFontError, SynthesizerError};
pub use sound_font::SoundFont;
pub use midi_file::{MidiFile, MidiEvent};
pub use midi_file_sequencer::MidiFileSequencer;
pub use synthesizer_settings::SynthesizerSettings;
pub use synthesizer::Synthesizer;
<span class="boring">}</span></code></pre></pre>
</li>
<li>This exports exactly the high-level types a user needs:<br />
• <code>SoundFont</code> (plus associated errors)<br />
• <code>MidiFile</code> (plus associated errors)<br />
• <code>SynthesizerSettings</code><br />
• <code>Synthesizer</code> (and its methods: <code>note_on</code>, <code>note_off</code>, <code>render</code>)<br />
• <code>MidiFileSequencer</code> (and its methods: <code>play</code>, <code>render</code>)</li>
</ul>
</li>
<li>
<p><strong>Run-time call graph</strong></p>
<ul>
<li>The user first loads a SoundFont (calling into <code>sound_font::SoundFont::new(...)</code>).</li>
<li>Then they construct a <code>Synthesizer</code>, which in turn calls into <code>reverb::Reverb::new</code>, <code>chorus::Chorus::new</code>, and sets up the voice‐pool (<code>Vec&lt;Voice&gt;</code>) inside <code>voice.rs</code>.</li>
<li>Each time <code>note_on</code> is invoked, <code>synthesizer::Synthesizer</code> instantiates a <code>Voice</code> by calling <code>voice::Voice::new(...)</code>. That in turn calls constructors in <code>oscillator</code>, <code>envelope</code>, <code>comb_filter</code>, and <code>all_pass_filter</code>.</li>
<li>On every audio block, <code>Synthesizer::render</code> loops over voices and calls <code>Voice::process_block</code>, which in turn calls:
<ul>
<li><code>Oscillator::next_sample</code> (in <code>oscillator.rs</code>)</li>
<li><code>Envelope::next_amplitude</code> (in <code>envelope.rs</code>)</li>
<li><code>CombFilter::process</code> (in <code>comb_filter.rs</code>)</li>
<li><code>AllPassFilter::process</code> (in <code>all_pass_filter.rs</code>)</li>
</ul>
</li>
<li>The block of per-voice samples is summed into a master buffer, then handed to <code>Reverb::process</code> (in <code>reverb.rs</code>) and <code>Chorus::process</code> (in <code>chorus.rs</code>), and finally scaled by <code>master_volume</code>.</li>
</ul>
</li>
<li>
<p><strong>Sequencer integration</strong></p>
<ul>
<li>If the user wants to play a MIDI file, they first call <code>MidiFile::new(...)</code> (in <code>midi_file.rs</code>) to parse tracks/events.</li>
<li>They then create a <code>MidiFileSequencer</code> (in <code>midi_file_sequencer.rs</code>), passing in the <code>Synthesizer</code>.</li>
<li>Each time they call <code>sequencer.render(...)</code>, the sequencer:
<ol>
<li>Advances its internal time cursor by <code>block_size</code> samples.</li>
<li>Emits any scheduled <code>NoteOn</code>/<code>NoteOff</code> events via <code>Synthesizer::note_on/ note_off</code>.</li>
<li>Calls <code>Synthesizer::render(...)</code> to fill the next block of audio.</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr />
<h3 id="in-a-nutshell"><a class="header" href="#in-a-nutshell">In a Nutshell</a></h3>
<ul>
<li><strong>“Structure dependency”</strong> (compile-time):</li>
</ul>
<pre><code>error.rs
↑
sound_font.rs       midi_file.rs
↑                    ↑
synthesizer_settings.rs
↑
synthesizer.rs ←─ voice.rs ←─ (oscillator.rs, envelope.rs, comb_filter.rs, all_pass_filter.rs)
↑                                     ↑
midi_file_sequencer.rs                └─ reverb.rs (also depends on comb &amp; all_pass)
└─ chorus.rs
</code></pre>
<ul>
<li><strong>“Call hierarchy”</strong> (run-time):</li>
</ul>
<ol>
<li>User → <code>SoundFont::new</code> (parses SF2)</li>
<li>User → <code>Synthesizer::new</code> (builds voice pool, effect units)</li>
<li>(Optional) User → <code>MidiFile::new</code> (parses MIDI file)</li>
<li>(Optional) User → <code>MidiFileSequencer::new(synth)</code></li>
<li>Each audio block →
<ul>
<li>Sequencer → <code>note_on</code>/<code>note_off</code> on <code>Synthesizer</code> for timed events</li>
<li>Sequencer (or user-thread) → <code>Synthesizer::render(left, right)</code><br />
• <code>Synthesizer::render</code> → calls each <code>Voice::process_block</code><br />
• <code>Voice::process_block</code> → <code>Oscillator::next_sample</code> → <code>Envelope::next_amplitude</code> → <code>CombFilter::process</code> → <code>AllPassFilter::process</code><br />
• After all voices are summed, <code>Synthesizer::render</code> → <code>Reverb::process</code> → <code>Chorus::process</code> → scale by master volume.</li>
</ul>
</li>
</ol>
<p>This should give you a clear picture of (a) how the modules depend on one another in the source tree, and (b) how, at run time, each call eventually fans out into the low-level DSP building blocks. We will explore any particular module more deeply—e.g. the exact algorithm inside <code>CombFilter::process</code> or how <code>PresetRegion</code> data flows into <code>Voice::new</code> next as needed.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../topics/audio.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../topics/broadcasting.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../topics/audio.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../topics/broadcasting.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
